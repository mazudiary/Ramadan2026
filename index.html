<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Ramadan Mubarak ü§ç</title>

<style>
html,body{
  margin:0;
  padding:0;
  overflow:hidden;
  background: radial-gradient(circle at top, #0f1533, #000);
  font-family:'Segoe UI',sans-serif;
  touch-action:none;
}


/* START OVERLAY */
#overlay{
  position:fixed;
  inset:0;
  background:radial-gradient(circle,#12183a,#000);
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  z-index:10;
  transition:opacity 1.2s ease;
}

#infoBtn{
  position: fixed;
  top: calc(14px + env(safe-area-inset-top));
  right: calc(14px + env(safe-area-inset-right));
  width:40px;
  height:40px;
  border-radius:999px;
  border:1px solid rgba(212,175,55,.55);
  background: rgba(0,0,0,0.25);
  color:#d4af37;
  font-size: 18px;
  line-height: 40px;
  text-align:center;
  cursor:pointer;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  transition: transform .2s ease, background .2s ease, box-shadow .2s ease;
  z-index: 11;
}

#infoBtn:hover{
  transform: translateY(-1px);
  background: rgba(212,175,55,0.14);
  box-shadow: 0 0 18px rgba(212,175,55,.28);
}

/* Notes modal */
#notesModal{
  position:fixed;
  inset:0;
  z-index: 12;
  display:none;
  place-items:center;
  padding: 22px;
  background: rgba(0,0,0,0.35);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

#notesModal[data-open="true"]{
  display:grid;
}

#notesCard{
  width: min(760px, calc(100% - 18px));
  max-height: min(78vh, 720px);
  overflow:auto;
  border-radius: 20px;
  border: 1px solid rgba(212,175,55,.25);
  background: rgba(8, 10, 18, 0.72);
  box-shadow: 0 16px 60px rgba(0,0,0,0.55);
}

#notesHeader{
  position: sticky;
  top: 0;
  display:flex;
  justify-content: space-between;
  align-items:center;
  gap: 12px;
  padding: 14px 16px;
  border-bottom: 1px solid rgba(255,255,255,0.10);
  background: rgba(8, 10, 18, 0.78);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

#notesHeader h2{
  margin:0;
  font-weight: 500;
  font-size: 1rem;
  letter-spacing: .6px;
}

#notesClose{
  padding: 10px 14px;
  border-radius: 999px;
  border: 1px solid rgba(212,175,55,.45);
  background: transparent;
  color: rgba(212,175,55,.95);
  cursor: pointer;
}

#notesBody{
  padding: 14px 18px 18px;
  line-height: 1.85;
  color: rgba(255,255,255,0.9);
}

#notesBody p{
  margin: 0 0 10px;
}

#overlay h1{
  color:#fff;
  font-weight:300;
  letter-spacing:4px;
}

#overlay button{
  margin-top:20px;
  padding:14px 36px;
  border-radius:40px;
  border:1px solid #d4af37;
  background:transparent;
  color:#d4af37;
  font-size:1rem;
  cursor:pointer;
  transition: transform .25s ease, box-shadow .25s ease, background .25s ease, color .25s ease;
}

#overlay button:hover{
  transform: translateY(-1px);
  background:#d4af37;
  color:#000;
  box-shadow: 0 0 18px rgba(212,175,55,.55);
}

/* TAP HINT */
#hint{
  position:fixed;
  bottom: calc(18px + env(safe-area-inset-bottom));
  width:100%;
  text-align:center;
  font-size:.8rem;
  color:#ffffffaa;
  opacity: 0;
  transition: opacity 600ms ease;
}

@media (prefers-reduced-motion: reduce) {
  #overlay { transition: opacity 0.01ms linear; }
  #hint { transition: opacity 0.01ms linear; }
}

/* Moon phase label */
#phaseLabel{
  position:fixed;
  top: calc(12px + env(safe-area-inset-top));
  left: calc(12px + env(safe-area-inset-left));
  padding:8px 12px;
  border-radius:999px;
  border:1px solid rgba(212,175,55,.35);
  background: rgba(0,0,0,0.25);
  color: rgba(255,255,255,0.85);
  font-size: .82rem;
  letter-spacing: .3px;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  z-index: 6;
  pointer-events:none;
}
</style>
</head>

<body>

<button id="infoBtn" type="button" aria-label="Info">i</button>

<div id="overlay">
  <h1>Ramadan Mubarak</h1>
  <button id="startBtn">Begin the Story</button>
</div>

<div id="notesModal" role="dialog" aria-modal="true" aria-labelledby="notesTitle" data-open="false">
  <div id="notesCard">
    <div id="notesHeader">
      <h2 id="notesTitle">Prayer / Wish Notes</h2>
      <button id="notesClose" type="button">Close</button>
    </div>
    <div id="notesBody"></div>
  </div>
</div>

<div id="hint">Tap i to read the prayer notes üåô</div>
<div id="phaseLabel" aria-hidden="true"></div>

<script type="importmap">
{
  "imports":{
    "three":"https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
    "three/addons/":"https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

/* ================= CONFIG ================= */
const PARTNER_NAME = "Premii ü§ç";
/* ========================================= */

function sanitizeFor3DText(s) {
  // Helvetiker typeface used by TextGeometry does not include emoji glyphs.
  // Remove non-ASCII characters to avoid rendering as "?".
  return String(s)
    .replace(/[^\x20-\x7E]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}

const PARTNER_NAME_3D = sanitizeFor3DText(PARTNER_NAME) || 'My Love';

const hintEl = document.getElementById("hint");
const overlayEl = document.getElementById("overlay");
const startBtn = document.getElementById("startBtn");
const infoBtn = document.getElementById('infoBtn');
const notesModal = document.getElementById('notesModal');
const notesClose = document.getElementById('notesClose');
const notesBody = document.getElementById('notesBody');

const prefersReducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
let isSmallScreen = Math.min(innerWidth, innerHeight) < 720;
let started = false;

const storyLines = [
  "Ramadan Mubarak ü§ç",
  "Please pray for us.",
  "Pray for my job.",
  "Pray for our marriage.",
  "Ramadan is the most blessed month for prayer.",
  "So I humbly ask you to remember us in your duas.",
  "Please pray especially after suhoor,",
  "and before iftar, while waiting to break your fast.",
  "At that moment, Allah says to the angels:",
  "‚ÄúLook at My servants. Food is ready before them, yet they choose not to eat for My sake.‚Äù",
  "At that time, Allah accepts all sincere duas.",
  "So please include us in your prayers during those precious moments.",
  "I want to live with you.",
  "I want to pray with you.",
  "I want to receive Allah‚Äôs gifts with you.",
  "And I want to see Allah in Jannatul Firdaus with you.",
  `Ameen ü§ç<br>${PARTNER_NAME}`
];

const phaseLabel = document.getElementById('phaseLabel');

function renderNotes() {
  // Show the full list of prayer/wish lines in a readable panel.
  const html = storyLines
    .map((line) => `<p>${line}</p>`)
    .join('');
  notesBody.innerHTML = html;
}

function openNotes() {
  renderNotes();
  notesModal.dataset.open = 'true';
}

function closeNotes() {
  notesModal.dataset.open = 'false';
}

/* ===== THREE SETUP ===== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x04040a);
scene.fog = new THREE.FogExp2(0x000000,0.0018);

const camera = new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,6,28);

const renderer = new THREE.WebGLRenderer({
  antialias: !(isSmallScreen || prefersReducedMotion),
  alpha: true,
  powerPreference: 'high-performance'
});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, isSmallScreen ? 1.5 : 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.15;
renderer.physicallyCorrectLights = true;
document.body.appendChild(renderer.domElement);

// Post-processing (soft bloom)
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(innerWidth, innerHeight),
  0.85,  // strength
  0.6,   // radius
  0.22   // threshold
);
composer.addPass(bloomPass);

function tuneBloomForDevice() {
  // Mobile screens + big white 3D text can blow out the bloom.
  // Keep it softer on small screens, but preserve the cinematic look on desktop.
  if (prefersReducedMotion) {
    bloomPass.strength = 0.35;
    bloomPass.radius = 0.25;
    bloomPass.threshold = 0.35;
    return;
  }

  if (isSmallScreen) {
    bloomPass.strength = 0.62;
    bloomPass.radius = 0.52;
    bloomPass.threshold = 0.28;
  } else {
    bloomPass.strength = 0.85;
    bloomPass.radius = 0.6;
    bloomPass.threshold = 0.22;
  }
}

tuneBloomForDevice();

const controls = new OrbitControls(camera,renderer.domElement);
controls.enableDamping=true;
controls.enablePan=false;
controls.minDistance=18;
controls.maxDistance=40;

// On mobile, prevent accidental camera moves while tapping.
if (isSmallScreen) {
  controls.enableRotate = false;
  controls.enableZoom = false;
}

/* ===== LIGHTS ===== */
scene.add(new THREE.AmbientLight(0x1b2140, 0.22));
const hemi = new THREE.HemisphereLight(0x2a4bff, 0x0b0614, 0.18);
scene.add(hemi);

// Sun (drives moon illumination)
const SUN_DISTANCE = 75;
const sunLight = new THREE.DirectionalLight(0xfff1d6, 1.25);
sunLight.position.set(0, 22, 60);
scene.add(sunLight);

const sunMat = new THREE.MeshBasicMaterial({ color: 0xfff2c2 });
sunMat.toneMapped = false; // keep it bright; bloom will pick it up
const sunMesh = new THREE.Mesh(new THREE.SphereGeometry(1.25, 28, 28), sunMat);
scene.add(sunMesh);

// Main key light to create a realistic crescent/shadow
const moonKey = new THREE.DirectionalLight(0xffffff, 2.3);
moonKey.position.set(12, 6, 18);
scene.add(moonKey);
const moonKeyBase = new THREE.Vector3(12, 6, 18);

// A helper direction vector we reuse
const sunDir = new THREE.Vector3(0, 0.35, 1).normalize();
const tmpVec3 = new THREE.Vector3();

// Warm fill light (soft)
const moonFill = new THREE.PointLight(0xffd4a3, 0.7, 120);
moonFill.position.set(-10, 2, 10);
scene.add(moonFill);

/* ===== MOON (procedural textures + bump/normal for realism) ===== */
function clamp01(v){ return Math.min(1, Math.max(0, v)); }

function seededRandom(seed){
  // Simple deterministic RNG
  let s = seed >>> 0;
  return () => {
    s = (s * 1664525 + 1013904223) >>> 0;
    return s / 4294967296;
  };
}

function generateMoonHeight(size = 512) {
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(size, size);
  const data = img.data;

  const rand = seededRandom(1337);
  // Base noise
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const i = (y * size + x) * 4;
      const n = rand();
      const m = rand();
      // A bit of multi-layer noise
      const v = clamp01(0.55 * n + 0.35 * m + 0.1 * ((x ^ y) % 7) / 7);
      const g = Math.floor(v * 255);
      data[i] = g;
      data[i + 1] = g;
      data[i + 2] = g;
      data[i + 3] = 255;
    }
  }
  ctx.putImageData(img, 0, 0);

  // Craters: draw soft rings (dents)
  ctx.globalCompositeOperation = 'source-over';
  const craterCount = Math.floor(size / 2.2);
  for (let c = 0; c < craterCount; c++) {
    const cx = Math.floor(rand() * size);
    const cy = Math.floor(rand() * size);
    const r = (rand() * 0.018 + 0.006) * size;
    const grd = ctx.createRadialGradient(cx, cy, r * 0.05, cx, cy, r);
    grd.addColorStop(0.0, 'rgba(0,0,0,0.00)');
    grd.addColorStop(0.35, 'rgba(0,0,0,0.10)');
    grd.addColorStop(0.70, 'rgba(255,255,255,0.06)');
    grd.addColorStop(1.0, 'rgba(0,0,0,0.12)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fill();
  }

  // Gentle blur via repeated scaled draws
  ctx.globalAlpha = 0.55;
  for (let k = 0; k < 3; k++) {
    ctx.drawImage(canvas, -1, -1);
    ctx.drawImage(canvas, 1, 1);
  }
  ctx.globalAlpha = 1;

  return canvas;
}

function makeNormalFromHeight(heightCanvas) {
  const size = heightCanvas.width;
  const hctx = heightCanvas.getContext('2d');
  const hImg = hctx.getImageData(0, 0, size, size);
  const hData = hImg.data;

  const nCanvas = document.createElement('canvas');
  nCanvas.width = size;
  nCanvas.height = size;
  const nctx = nCanvas.getContext('2d');
  const nImg = nctx.createImageData(size, size);
  const nData = nImg.data;

  const strength = 2.2;
  const idx = (x, y) => (y * size + x) * 4;
  const sample = (x, y) => {
    x = (x + size) % size;
    y = (y + size) % size;
    return hData[idx(x, y)] / 255;
  };

  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const hl = sample(x - 1, y);
      const hr = sample(x + 1, y);
      const hd = sample(x, y - 1);
      const hu = sample(x, y + 1);
      const dx = (hl - hr) * strength;
      const dy = (hd - hu) * strength;

      // Normal vector
      let nx = dx;
      let ny = dy;
      let nz = 1.0;
      const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
      nx /= len; ny /= len; nz /= len;

      const i = idx(x, y);
      nData[i] = Math.floor((nx * 0.5 + 0.5) * 255);
      nData[i + 1] = Math.floor((ny * 0.5 + 0.5) * 255);
      nData[i + 2] = Math.floor((nz * 0.5 + 0.5) * 255);
      nData[i + 3] = 255;
    }
  }

  nctx.putImageData(nImg, 0, 0);
  return nCanvas;
}

function generateMoonAlbedo(size = 512, heightCanvas) {
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');

  // Base albedo
  ctx.fillStyle = '#d8d5d1';
  ctx.fillRect(0, 0, size, size);

  // Add "maria" darker patches
  const rand = seededRandom(2024);
  ctx.globalAlpha = 0.35;
  for (let i = 0; i < 70; i++) {
    const x = rand() * size;
    const y = rand() * size;
    const r = (rand() * 0.09 + 0.02) * size;
    const g = ctx.createRadialGradient(x, y, 0, x, y, r);
    g.addColorStop(0, 'rgba(80,80,90,0.40)');
    g.addColorStop(1, 'rgba(80,80,90,0.00)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Multiply in height detail for subtle texture
  if (heightCanvas) {
    ctx.globalCompositeOperation = 'multiply';
    ctx.globalAlpha = 0.75;
    ctx.drawImage(heightCanvas, 0, 0, size, size);
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }

  return canvas;
}

function createFresnelMaterial() {
  return new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms: {
      uColor: { value: new THREE.Color(0xffe7b0) },
      uPower: { value: 2.4 },
      uIntensity: { value: 0.55 }
    },
    vertexShader: `
      varying vec3 vNormal;
      varying vec3 vViewDir;
      void main() {
        vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
        vNormal = normalize(normalMatrix * normal);
        vViewDir = normalize(-mvPos.xyz);
        gl_Position = projectionMatrix * mvPos;
      }
    `,
    fragmentShader: `
      uniform vec3 uColor;
      uniform float uPower;
      uniform float uIntensity;
      varying vec3 vNormal;
      varying vec3 vViewDir;
      void main() {
        float fres = pow(1.0 - clamp(dot(vNormal, vViewDir), 0.0, 1.0), uPower);
        float a = fres * uIntensity;
        gl_FragColor = vec4(uColor, a);
      }
    `
  });
}

const moonTexSize = (isSmallScreen || prefersReducedMotion) ? 512 : 768;
const moonHeight = generateMoonHeight(moonTexSize);
const moonNormal = makeNormalFromHeight(moonHeight);
const moonAlbedo = generateMoonAlbedo(moonTexSize, moonHeight);

const moonMap = new THREE.CanvasTexture(moonAlbedo);
moonMap.colorSpace = THREE.SRGBColorSpace;
moonMap.anisotropy = 8;

const moonBump = new THREE.CanvasTexture(moonHeight);
moonBump.anisotropy = 8;

const moonNorm = new THREE.CanvasTexture(moonNormal);
moonNorm.anisotropy = 8;

const moon = new THREE.Mesh(
  new THREE.SphereGeometry(6.2, (isSmallScreen ? 96 : 128), (isSmallScreen ? 96 : 128)),
  new THREE.MeshStandardMaterial({
    map: moonMap,
    normalMap: moonNorm,
    displacementMap: moonBump,
    displacementScale: 0.12,
    roughness: 0.95,
    metalness: 0.0
  })
);
moon.position.set(0, 0, 0);
scene.add(moon);

// Crescent silhouette (CSG-like cutout) while preserving texture & PBR lighting.
// We "subtract" an offset sphere in shader by discarding fragments inside it.
const crescent = {
  occluderPos: new THREE.Vector3(1.75, 0.25, 0.15),
  occluderRadius: 6.55
};

// 3D moon phases (drives both cutout and key light direction)
const PHASES = [
  { name: 'New Moon', t: 0.00 },
  { name: 'Waxing Crescent', t: 0.12 },
  { name: 'First Quarter', t: 0.25 },
  { name: 'Waxing Gibbous', t: 0.38 },
  { name: 'Full Moon', t: 0.50 },
  { name: 'Waning Gibbous', t: 0.62 },
  { name: 'Last Quarter', t: 0.75 },
  { name: 'Waning Crescent', t: 0.88 }
];

let phaseIndex = 1; // start near crescent
let phaseT = PHASES[phaseIndex].t;

// Animate to full moon in 10 seconds (after start)
const FULL_MOON_T = 0.5;
const FULL_MOON_SECONDS = 10;
let fullMoonMode = false;
let fullMoonStartTime = 0;
let fullMoonFromT = phaseT;

function easeInOutCubic(x){
  return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
}

function applyMoonPhase(t, updateLabel = false, label) {
  // t in [0..1], where 0 and 1 are new moon, 0.5 is full.
  const tt = ((t % 1) + 1) % 1;
  phaseT = tt;

  // Map phase to occluder sphere offset.
  // New moon: occluder centered -> discards almost all. Full: occluder far away -> discards none.
  const xOffset = (tt - 0.5) * 4.6; // [-2.3..+2.3]
  const yOffset = 0.10 + Math.sin(tt * Math.PI * 2) * 0.08;
  crescent.occluderPos.set(xOffset, yOffset, 0.15);

  // Larger occluder keeps the crescent edge smooth; adjust slightly by phase
  crescent.occluderRadius = 6.5 + Math.cos(tt * Math.PI * 2) * 0.08;

  // Place the sun around the scene based on phase.
  // New (0.0): sun roughly behind the moon from camera direction.
  // Full (0.5): sun roughly behind the camera (moon is fully lit).
  const ang = tt * Math.PI * 2;
  sunDir.set(Math.sin(ang), 0.35, Math.cos(ang)).normalize();

  // Sun position (visual)
  sunLight.position.copy(sunDir).multiplyScalar(SUN_DISTANCE);
  sunMesh.position.copy(sunDir).multiplyScalar(SUN_DISTANCE * 0.86);

  // Moon illumination follows the sun
  moonKeyBase.copy(sunDir).multiplyScalar(18);
  moonKey.color.copy(sunLight.color);
  moonKey.intensity = sunLight.intensity * 1.9;
  moonFill.intensity = sunLight.intensity * 0.55;

  // Update shader uniforms immediately if compiled
  if (moon.material.userData.shader) {
    const sh = moon.material.userData.shader;
    sh.uniforms.uOccPos.value.copy(crescent.occluderPos);
    sh.uniforms.uOccR.value = crescent.occluderRadius;
  }

  if (updateLabel) {
    phaseLabel.textContent = label ? `Moon phase: ${label}` : `Moon phase: ${Math.round(tt * 100)}%`;
  }
}

function setMoonPhase(t, label) {
  applyMoonPhase(t, true, label);
}

function nextMoonPhase(step = 1) {
  phaseIndex = (phaseIndex + step + PHASES.length) % PHASES.length;
  const p = PHASES[phaseIndex];
  setMoonPhase(p.t, p.name);
}

moon.material.onBeforeCompile = (shader) => {
  shader.uniforms.uOccPos = { value: crescent.occluderPos };
  shader.uniforms.uOccR = { value: crescent.occluderRadius };

  shader.vertexShader = shader.vertexShader
    .replace(
      '#include <common>',
      '#include <common>\nvarying vec3 vObjPos;'
    )
    .replace(
      '#include <begin_vertex>',
      '#include <begin_vertex>\nvObjPos = position;'
    );

  shader.fragmentShader = shader.fragmentShader
    .replace(
      '#include <common>',
      '#include <common>\nvarying vec3 vObjPos;\nuniform vec3 uOccPos;\nuniform float uOccR;'
    )
    .replace(
      'void main() {',
      'void main() {\n  if (length(vObjPos - uOccPos) < uOccR) discard;'
    );

  moon.material.userData.shader = shader;
};
moon.material.needsUpdate = true;

// Rim glow / halo (adds depth)
const moonHalo = new THREE.Mesh(
  new THREE.SphereGeometry(6.35, (isSmallScreen ? 72 : 96), (isSmallScreen ? 72 : 96)),
  createFresnelMaterial()
);
moonHalo.renderOrder = 2;
scene.add(moonHalo);

/* ===== STARS (layered depth) ===== */
function makeStarLayer(count, spread, size, opacity) {
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count * 3);
  const rand = seededRandom(Math.floor(999 + size * 1000));
  for (let i = 0; i < pos.length; i += 3) {
    pos[i] = (rand() - 0.5) * spread;
    pos[i + 1] = (rand() - 0.5) * spread;
    pos[i + 2] = (rand() - 0.5) * spread;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  const mat = new THREE.PointsMaterial({
    size,
    color: 0xffffff,
    transparent: true,
    opacity,
    depthWrite: false
  });
  return new THREE.Points(geo, mat);
}

const starsFar = makeStarLayer(isSmallScreen ? 950 : 1400, 420, 0.35, 0.45);
const starsMid = makeStarLayer(isSmallScreen ? 700 : 1000, 320, 0.55, 0.65);
const starsNear = makeStarLayer(isSmallScreen ? 520 : 700, 240, 0.85, 0.85);
scene.add(starsFar, starsMid, starsNear);

/* ===== LANTERNS ===== */
const lanterns=[];
const lanternSmokes=[];

function createSoftParticleTexture(){
  const c = document.createElement('canvas');
  c.width = 128;
  c.height = 128;
  const ctx = c.getContext('2d');
  const g = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
  g.addColorStop(0, 'rgba(255,255,255,0.95)');
  g.addColorStop(0.25, 'rgba(255,255,255,0.45)');
  g.addColorStop(1, 'rgba(255,255,255,0.0)');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, 128, 128);
  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  return tex;
}

const smokeTex = createSoftParticleTexture();

function createLanternSmoke(count = 140){
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count * 3);
  const speed = new Float32Array(count);
  const phase = new Float32Array(count);
  for (let i = 0; i < count; i++) {
    // Small cone above lantern top
    pos[i * 3 + 0] = (Math.random() - 0.5) * 0.9;
    pos[i * 3 + 1] = Math.random() * 3.5; // height
    pos[i * 3 + 2] = (Math.random() - 0.5) * 0.9;
    speed[i] = 0.45 + Math.random() * 0.75;
    phase[i] = Math.random() * Math.PI * 2;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('aSpeed', new THREE.BufferAttribute(speed, 1));
  geo.setAttribute('aPhase', new THREE.BufferAttribute(phase, 1));
  geo.attributes.position.setUsage(THREE.DynamicDrawUsage);

  const mat = new THREE.PointsMaterial({
    map: smokeTex,
    size: 0.55,
    sizeAttenuation: true,
    color: 0xfff1d4,
    transparent: true,
    opacity: 0.22,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  const pts = new THREE.Points(geo, mat);
  pts.position.set(0, 1.05, 0);
  return pts;
}

for(let i=0;i<3;i++){
  const l=new THREE.Mesh(
    new THREE.CylinderGeometry(.6,.8,2.2,12),
    new THREE.MeshStandardMaterial({
      color:0xffc96b,
      emissive:0xffaa33,
      emissiveIntensity:.4
    })
  );
  l.position.set(Math.sin(i*2)*10,-6,Math.cos(i*2)*10);
  l.visible=false;

  // Inner light glow
  const inner = new THREE.PointLight(0xffc96b, 1.2, 26, 2);
  inner.position.set(0, 0.2, 0);
  l.add(inner);

  // Small inner orb for glow bloom
  const orb = new THREE.Mesh(
    new THREE.SphereGeometry(0.22, 16, 16),
    new THREE.MeshStandardMaterial({
      color: 0xffe2a8,
      emissive: 0xffc96b,
      emissiveIntensity: 1.25,
      roughness: 0.4,
      metalness: 0.0
    })
  );
  orb.position.set(0, 0.2, 0);
  l.add(orb);

  // Smoke / shimmer particles
  const smoke = createLanternSmoke(isSmallScreen ? 95 : 140);
  l.add(smoke);
  lanternSmokes.push(smoke);

  scene.add(l);
  lanterns.push(l);
}

/* ===== TEXT ===== */
let finalText;

function layoutFinalText() {
  if (!finalText) return;
  // Recompute on resize/orientation changes.
  const narrow = Math.min(innerWidth, innerHeight) < 720;
  const portrait = innerHeight > innerWidth;

  // Scale down so it fits and doesn't clip.
  finalText.scale.setScalar(narrow ? 0.78 : 0.95);

  // Place the text clearly UNDER the moon, especially on portrait mobile.
  // Push a bit farther from camera to reduce bloom blowout.
  finalText.position.set(0, portrait ? -6.8 : -6.2, portrait ? 11.8 : 10.8);
}

new FontLoader().load(
  "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/fonts/helvetiker_regular.typeface.json",
  font=>{
    finalText=new THREE.Mesh(
      new TextGeometry(`Ramadan Mubarak\n${PARTNER_NAME_3D}`,{
        font,
        size:1,
        height:.2,
        bevelEnabled:true,
        bevelSize:.03,
        bevelThickness:.04
      }),
      new THREE.MeshStandardMaterial({
        color:0xfffbf2,
        emissive:0xffffff,
        emissiveIntensity:.18,
        roughness: 0.55,
        metalness: 0.0
      })
    );
    finalText.geometry.center();
    layoutFinalText();
    finalText.visible=false;
    scene.add(finalText);
  }
);

let revealFinalTextAfterFullMoon = false;

/* ===== START ===== */
function startStory(){
  if (started) return;
  started = true;

  overlayEl.style.opacity=0;
  setTimeout(()=>overlayEl.remove(),1200);
  hintEl.style.opacity = 1;
  setMoonPhase(PHASES[phaseIndex].t, PHASES[phaseIndex].name);

  // Start "reach full moon in 10 seconds" animation
  fullMoonMode = true;
  fullMoonStartTime = performance.now();
  fullMoonFromT = phaseT;

  // Show lanterns immediately now that the story overlay is removed
  lanterns.forEach(l=>l.visible=true);

  // Reveal the final 3D greeting when the full moon completes
  revealFinalTextAfterFullMoon = true;
}

startBtn.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  e.stopPropagation();
  startStory();
}, { passive: false });

infoBtn.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  e.stopPropagation();
  openNotes();
}, { passive: false });

notesClose.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  e.stopPropagation();
  closeNotes();
}, { passive: false });

notesModal.addEventListener('pointerdown', (e) => {
  // Click outside the card closes.
  if (e.target === notesModal) closeNotes();
});

overlayEl.addEventListener('pointerdown', (e) => {
  // Tapping the overlay background (not buttons) opens notes.
  if (!started && e.target === overlayEl) openNotes();
}, { passive: true });

// Story overlay removed: no tap-to-advance handler.

// Keyboard support for phase cycling
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') closeNotes();
  if (e.key === 'i' || e.key === 'I') openNotes();
  if (!started) return;
  if (e.key === 'ArrowRight') nextMoonPhase(1);
  if (e.key === 'ArrowLeft') nextMoonPhase(-1);
});

/* ===== ANIMATE ===== */
const clock=new THREE.Clock();
let paused = false;
let rafId = null;

function loop(){
  if (paused) {
    rafId = null;
    return;
  }

  rafId = requestAnimationFrame(loop);
  const t=clock.getElapsedTime();

  // Phase automation: reach full moon in 10 seconds after start
  if (fullMoonMode) {
    const elapsed = (performance.now() - fullMoonStartTime) / 1000;
    const p = Math.min(1, elapsed / FULL_MOON_SECONDS);
    const eased = easeInOutCubic(p);
    const tt = fullMoonFromT + (FULL_MOON_T - fullMoonFromT) * eased;
    applyMoonPhase(tt, false);
    if (p >= 1) {
      fullMoonMode = false;
      setMoonPhase(FULL_MOON_T, 'Full Moon');

      if (revealFinalTextAfterFullMoon && finalText) {
        finalText.visible = true;
        revealFinalTextAfterFullMoon = false;
      }
    }
  } else {
    // Add a tiny "breathing" drift to the current phase (keeps it alive)
    const drift = prefersReducedMotion ? 0 : (Math.sin(t * 0.06) * 0.004);
    applyMoonPhase(phaseT + drift, false);
  }

  const motion = prefersReducedMotion ? 0.35 : 1;
  moon.rotation.y += 0.0016 * motion;
  moon.rotation.x = Math.sin(t * 0.12) * 0.03 * motion;
  moonHalo.rotation.copy(moon.rotation);
  moon.scale.setScalar(1 + Math.sin(t * 0.8) * 0.02 * motion);

  // Slowly animate light angle for a living crescent feel
  moonKey.position.copy(moonKeyBase);
  // slight wobble without breaking the sun direction too much
  tmpVec3.set(
    Math.sin(t * 0.18) * 0.6 * motion,
    Math.cos(t * 0.12) * 0.35 * motion,
    0
  );
  moonKey.position.add(tmpVec3);

  // Sun shimmer (subtle intensity breathing)
  sunLight.intensity = 1.22 + Math.sin(t * 0.12) * 0.06 * motion;

  starsFar.rotation.y -= 0.00018;
  starsMid.rotation.y -= 0.00028;
  starsNear.rotation.y -= 0.00038;

  lanterns.forEach((l,i)=>{
    l.position.y=Math.sin(t+i)*.6-3;
    l.rotation.y+=.01;
  });

  // Smoke shimmer update
  if (!prefersReducedMotion) {
    for (let li = 0; li < lanternSmokes.length; li++) {
      const pts = lanternSmokes[li];
      const geo = pts.geometry;
      const pos = geo.attributes.position.array;
      const speed = geo.attributes.aSpeed.array;
      const phase = geo.attributes.aPhase.array;
      for (let p = 0; p < speed.length; p++) {
        const i3 = p * 3;
        pos[i3 + 1] += speed[p] * 0.012;
        pos[i3 + 0] += Math.sin(t * 1.2 + phase[p]) * 0.0015;
        pos[i3 + 2] += Math.cos(t * 1.1 + phase[p]) * 0.0015;
        if (pos[i3 + 1] > 3.8) {
          pos[i3 + 1] = 0;
          pos[i3 + 0] = (Math.random() - 0.5) * 0.9;
          pos[i3 + 2] = (Math.random() - 0.5) * 0.9;
        }
      }
      geo.attributes.position.needsUpdate = true;
    }
  }

  controls.update();
  composer.render();
}

function setPaused(nextPaused) {
  paused = nextPaused;
  if (!paused && rafId == null) {
    clock.getDelta();
    rafId = requestAnimationFrame(loop);
  }
}

document.addEventListener('visibilitychange', () => {
  setPaused(document.hidden);
});

setPaused(false);

window.addEventListener("resize",()=>{
  isSmallScreen = Math.min(innerWidth, innerHeight) < 720;
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, isSmallScreen ? 1.5 : 2));
  composer.setSize(innerWidth, innerHeight);
  bloomPass.setSize(innerWidth, innerHeight);
  tuneBloomForDevice();
  layoutFinalText();

  // Update controls behavior for mobile/desktop transitions.
  controls.enableRotate = !isSmallScreen;
  controls.enableZoom = !isSmallScreen;
});
</script>

</body>
</html>
